import{html,render as litRender}from"lit-html";export const LitElement=t=>class extends t{constructor(){super(),this.__data={},this._methodsToCall={},this.attachShadow({mode:"open"})}static observedAttributes(){let t=[];for(const e in this.properties)this.properties[e].reflectToAttribute&&t.push(e);return t}connectedCallback(){const t=this.constructor.properties;this._wait=!0;for(let e in t)this._makeGetterSetter(e,t[e]);delete this._wait,litRender(this.render(),this.shadowRoot),this.afterFirstRender&&this.afterFirstRender()}_makeGetterSetter(t,e){Object.defineProperty(this,t,{get(){return this.__data[t]},set(r){"object"==typeof e&&(!e.reflectToAttribute||e.type!==Object&&e.type!==Array||console.warn("Rich Data shouldn't be set as attribte!")),"object"==typeof e&&e.reflectToAttribute?this.setAttribute(t,r):this.__data[t]=r,this._propertiesChanged(t,r)}}),"object"==typeof e&&(e.observer&&(this[e.observer]?this._methodsToCall[t]=this[e.observer].bind(this):console.warn(`Method ${e.observer} not defined!`)),e.value&&("function"==typeof e.value?this[t]=e.value():this[t]=e.value)),this[t]=this.getAttribute(t)}_propertiesChanged(t,e){this._methodsToCall[t]&&this._methodsToCall[t](e),this._wait||litRender(this.render(),this.shadowRoot)}attributeChangedCallback(t,e,r){if(this[t]!==r){const{type:e}=this.constructor.properties[t];"Boolean"===e.name?this.__data[t]="false"!==r&&this.hasAttribute(t):this.__data[t]=e(r),this._propertiesChanged(t,r)}}render(){return html``}get $(){const t=this.shadowRoot.querySelectorAll("[id]"),e={};for(const r of t)e[r.id]=r;return e}};